# 题目描述

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

# 示例:

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

# 注意点

0 <= 链表长度 <= 1000

# 解法一：迭代法

> 解题思路：根据题目描述， 链表 $l_1, l_2$ 是递增的，因此容易想到使用双指针 $l_1, l_2$ 遍历两链表，根据 $l_1.val, l_2.val$ 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕

- 算法流程：

  1. **初始化：** 伪头节点 dum ，节点 cur 指向 dum
  2. **循环合并：** 当 $l_1, l_2$ 为空时跳出
     1. 当 $l_1.val < l_2.val$ 时：cur 的后继节点指定为 $l_1$，并 $l_1$ 向前走一步
     2. 当 $l_1.val >= l_2.val$ 时：cur 的后继节点指定为 $l_2$，并 $l_2$ 向前走一步
     3. 节点 cur 向前走一步，即 cur = cur.next
  3. **合并剩余尾部：** 跳出时有两种情况，即 $l_1$ 为空或 $l_2$ 为空
     1. 若 $l_1$ != null ： 将 $l_1$ 添加至节点 cur 之后
     2. 否则： 将 $l_2$ 添加至节点 cur 之后
  4. **返回值：** 合并链表在伪头节点 dum 之后，因此返回 dum.next 即可

- 复杂度分析：

  - **时间复杂度 O(M+N)：** M, N 分别为链表 $l_1, l_2$ 的长度，合并操作需遍历两链表
  - **空间复杂度 O(1)：** 节点引用 dum, cur 使用常数大小的额外空间


![图解](https://pic.leetcode-cn.com/88ea6a5ecc6e86d0c1b1e334f764476385ccaecaf1cb18db38be3b47cedda965-Picture4.png)

# 解法二：递归法

- 复杂度分析：

  - **时间复杂度 O(M+N)：** M, N 分别为链表 $l_1, l_2$ 的长度
  - **空间复杂度 O(1)** 