# 题目描述

输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

# 示例

给定一个链表: 1->2->3->4->5, 和 k = 2, 返回链表 4->5.

# 注意点

实际上应该考虑的特殊情况有：

1. head 为空指针；
2. k 大于链表的长度；
3. 输入的参数 k 为 0； 鲁棒性也是很重要的~

# 方法一：遍历

> 解题思路：先遍历统计链表长度，记为 n ；设置一个指针走 (n−k) 步，即可找到链表倒数第 k 个节点。

- 复杂度分析

  - **时间复杂度 O(N)：** N 为链表长度；总体看，先遍历统计链表长度走了 N， 再设置一个指针走了 (N−k) 步。
  - **空间复杂度 O(1)：** 指针 `node` 和计数变量 `count` 使用常数大小的额外空间

![遍历](https://pic.leetcode-cn.com/ab52aeb21d3ea0c2b2aaca94241413db5d060b88e950461953db64e36a89a435-Picture0.png)

# 方法二：双指针

> 解题思路：不需要知道链表长度，指针 1 先走 k-1 步，然后指针 2 和指针 1 同时前进，当指针 1 指向链表最后一个元素时，指针 2 即为所求。

- 算法流程

  - **初始化：** 前指针 `former` 、后指针 `latter` ，双指针都指向头节点 `head​`
  - **构建双指针距离：** 前指针 `former` 先向前走 k 步（结束后，双指针 `former` 和 `latter` 间相距 k 步）
  - **双指针共同移动：** 循环中，双指针 `former` 和 `latter` 每轮都向前走一步，直至 `former` 走过链表 尾节点 时跳出（跳出后， `latter` 与尾节点距离为 k−1，即 `latter` 指向倒数第 k 个节点）
  - **返回值：** 返回 `latter` 即可

- 复杂度分析

  - **时间复杂度 O(N)：** N 为链表长度；总体看， `former` 走了 N 步， `latter` 走了 (N−k) 步。
  - **空间复杂度 O(1)：** 双指针 `former` , `latter` 使用常数大小的额外空间

![双指针](https://pic.leetcode-cn.com/924c58447a25fdfa664dba9649d83e2e0b41a7136238696bfb24a363cbc68bb2-Picture7.png)
